#!/usr/bin/perl -w
use strict;
use Data::Dumper;
use XML::XPath;
use XML::XPath::XMLParser;
use Storable qw(nfreeze thaw);
use IO::Compress::Bzip2 qw(bzip2 $Bzip2Error);
use IO::Uncompress::Bunzip2 qw(bunzip2 $Bunzip2Error);
use Carp;

use Getopt::Long;

my ( $nvd, $store, $cwe );

my $result = GetOptions(
    "nvd=s"   => \$nvd,
    "cwe=s"   => \$cwe,
    "store=s" => \$store,
);

use NIST::NVD::Update;

$nvd ||= 'nvdcve-2.0-recent.xml';
$cwe ||= 'cwec_v2.1.xml';

$store ||= 'DB_File';

print STDERR "using store [$store]\n";

my $db_file = 'nvdcve-2.0.db';

my $NVD_Updater = NIST::NVD::Update->new(
    store    => $store,
    database => $db_file,
);

my %vuln_software;
my %weaknesses;

$|++;

print("reading NVDs from file: $nvd...");

my $nvd_entries = process_nvd_file($nvd);

printf( "read \%i entries\n", int keys $nvd_entries );

print "Processing CWE file...";

my $cwe_data = process_cwe_file($cwe);

print "Done.\n";

print "Writing CPE URNs to disk...";

$NVD_Updater->put_cpe( [ keys %vuln_software ] );

print "Done.\n";

print "Writing NVD entries to disk...";

$NVD_Updater->put_nvd_entries($nvd_entries);

print " Done.\n";

print "Writing CPE index to disk...";

$NVD_Updater->put_idx_cpe( \%vuln_software );

print "Done.\n";

sub process_nvd_file {

    my ($filename) = @_;

    my $NVD_Entry_HASH = {};

    my $content;

    my $iter = 0;

    my $header;
    my $entry_body;
    my $footer = '</nvd>';

    my $nvdcve_fd;

    open( $nvdcve_fd, q{<}, $filename )
        or die qq{couldn't open "$filename": $!};

    while ( my $line = <$nvdcve_fd> ) {

        if ( $line =~ /(^.*?)<entry/ ) {
            my $tail = $1;
            $content .= $tail;

            if ($header) {
                $entry_body = $content;
                my $xml_string = $header . $entry_body . $footer;
                print(".");
                my %entry = process_nvd($xml_string);

                while ( my ( $cve_id, $entry ) = each %entry ) {
                    $NVD_Entry_HASH->{$cve_id} = $entry;
                }

                $iter++;
            } else {
                $header = $content;
            }

            $line =~ s/^$tail//;
            $content = $line;

        } else {
            $content .= $line;
        }
    }

    return $NVD_Entry_HASH;

}

sub process_nvd {
    my ($xml) = @_;

    my $xp = XML::XPath->new( xml => $xml );

    my $nodeset = $xp->find('/nvd');

    my @nvd_nodelist
        = grep { $_->getName && $_->getName eq 'nvd' } $nodeset->get_nodelist;

    my %entry = ();

    foreach my $nvd (@nvd_nodelist) {
        my @entry_nodelist = grep { $_->getName && $_->getName eq 'entry' }
            $nvd->getChildNodes();

        foreach my $entry_node (@entry_nodelist) {
            my $entry = process_entry( $entry_node, $nvd );

            my $cve_id = $entry->{'vuln:cve-id'};

            foreach
                my $cpe_urn ( @{ $entry->{'vuln:vulnerable-software-list'} } )
            {
                push( @{ $vuln_software{$cpe_urn} }, $cve_id );
            }

            foreach my $cwe_id ( @{ $entry->{'vuln:cwe'} } ) {
                push( @{ $weaknesses{$cve_id} }, $cwe_id );
            }

            $entry{$cve_id} = $entry;
        }
    }

    return (%entry);

    #  $xp->dispose();
}

sub process_entry {
    my ( $entry, $nvd ) = @_;

    my $results = {};

    foreach my $vuln ( $entry->getChildNodes() ) {
        next unless $vuln->getName();
        my $nodeName = $vuln->getName();

        if ( $nodeName eq 'vuln:vulnerable-configuration' ) {
            push( @{ $results->{$nodeName} }, process_vuln_config($vuln) );
        } elsif ( $nodeName eq 'vuln:vulnerable-software-list' ) {
            $results->{$nodeName} = process_vuln_software_list($vuln);
        } elsif ( $nodeName eq 'vuln:cve-id' ) {
            $results->{$nodeName} = $vuln->string_value();
        } elsif ( $nodeName eq 'vuln:discovered-datetime' ) {
            $results->{$nodeName} = $vuln->string_value();
        } elsif ( $nodeName eq 'vuln:published-datetime' ) {
            $results->{$nodeName} = $vuln->string_value();
        } elsif ( $nodeName eq 'vuln:last-modified-datetime' ) {
            $results->{$nodeName} = $vuln->string_value();
        } elsif ( $nodeName eq 'vuln:cvss' ) {
            $results->{$nodeName} = process_vuln_cvss($vuln);
        } elsif ( $nodeName eq 'vuln:cwe' ) {
            push( @{ $results->{$nodeName} }, $vuln->getAttribute('id') );
        } elsif ( $nodeName eq 'vuln:references' ) {
            push( @{ $results->{$nodeName} },
                process_vuln_references($vuln) );
        } elsif ( $nodeName eq 'vuln:summary' ) {
            $results->{$nodeName} = $vuln->string_value();
        } elsif ( $nodeName eq 'vuln:security-protection' ) {
            $results->{$nodeName} = $vuln->string_value();
        } elsif ( $nodeName eq 'vuln:assessment_check' ) {
            push(
                @{ $results->{$nodeName} },
                {   map { $_->getName() => $_->getNodeValue() }
                        ( $vuln->getAttributes() )
                }
            );
        } elsif ( $nodeName eq 'vuln:scanner' ) {
            push( @{ $results->{$nodeName} }, process_vuln_scanner($vuln) );
        } else {
            print(    "}elsif( \$vuln->getName() eq '"
                    . $vuln->getName
                    . "' ){\n" );
            exit;
        }
    }

    return $results;
}

sub process_vuln_config {
    my ($vuln) = @_;

    my $results = {};

    foreach my $node ( $vuln->getChildNodes() ) {
        next unless $node->getName();
        my $nodeName = $node->getName();

        die "}elsif( \$nodeName eq '$nodeName' ){\n"
            unless ( $nodeName eq 'cpe-lang:logical-test' );

        push( @{ $results->{$nodeName} }, process_cpe_logical_test($node) );
    }

    return $results;
}

sub process_cpe_logical_test {
    my ($logical_test) = @_;
    my $logTestName = $logical_test->getName();

    my $results = {};

    foreach my $attr ( $logical_test->getAttributes() ) {
        $results->{attr}->{ $attr->getName() } = $attr->getNodeValue();
    }

    foreach my $node ( $logical_test->getChildNodes() ) {
        my $nodeName = $node->getName();
        next unless $nodeName;

        if ( $nodeName eq 'cpe-lang:fact-ref' ) {
            push( @{ $results->{$nodeName} }, $node->getAttribute('name') );
        } elsif ( $nodeName eq 'cpe-lang:logical-test' ) {
            push(
                @{ $results->{$nodeName} },
                process_cpe_logical_test($node)
            );
        } else {
            die
                "this logical test element looks invalid.  This element is a(n) [$nodeName]";
        }
    }

    return $results;
}

sub process_vuln_software_list {
    my ($vuln) = @_;
    my $vulnName = $vuln->getName();

    my $results = [];

    foreach my $node ( $vuln->getChildNodes() ) {
        my $nodeName = $node->getName();
        next unless $nodeName;

        die qq[}elsif( \$nodeName eq '$nodeName' ){]
            unless $nodeName eq 'vuln:product';

        push( @$results, $node->string_value() );
    }

    return $results;
}

sub process_vuln_cvss {
    my ($vuln) = @_;

    my $vulnName = $vuln->getName();

    my $results = {};

    foreach my $attr ( $vuln->getAttribute() ) {
        next unless $attr;
        $results->{attr}->{ $attr->getName() } = $attr->getNodeValue();
    }

    foreach my $node ( $vuln->getChildNodes() ) {
        my $nodeName = $node->getName();
        next unless $nodeName;

        if ( $nodeName eq 'cvss:base_metrics' ) {
            $results->{$nodeName} = {};
            foreach my $metric ( $node->getChildNodes() ) {
                my $metricName = $metric->getName();
                next unless $metricName;

                $results->{$nodeName}->{$metricName}
                    = $metric->string_value();
            }
        } else {
            die qq[}elsif( \$nodeName eq '$nodeName' ){];
        }

    }

    return $results;
}

sub process_vuln_references {
    my ($vuln) = @_;

    my $vulnName = $vuln->getName();

    my $results = {};

    foreach my $attr ( $vuln->getAttributes() ) {
        next unless $attr;
        $results->{attr}->{ $attr->getName() } = $attr->getNodeValue();
    }

    foreach my $node ( $vuln->getChildNodes() ) {
        my $nodeName = $node->getName();
        next unless $nodeName;

        if ( $nodeName eq 'vuln:reference' ) {
            push( @{ $results->{$nodeName} },
                process_vuln_references($node) );
        } elsif ( $nodeName eq 'vuln:source' ) {
            $results->{$nodeName} = $node->string_value();
        } else {
            die qq[}elsif( \$nodeName eq '$nodeName' ){];
        }
    }

    return $results;
}

sub process_vuln_scanner {
    my ($vuln) = @_;

    my $vulnName = $vuln->getName();

    my $results = {};

    foreach my $node ( $vuln->getChildNodes() ) {
        my $nodeName = $node->getName();
        next unless $nodeName;

        if ( $nodeName eq 'vuln:definition' ) {
            foreach my $attr ( $node->getAttributes() ) {
                next unless $attr;
                $results->{$nodeName}->{ $attr->getName() }
                    = $attr->getNodeValue();
            }
        } else {
            die qq[}elsif( \$nodeName eq '$nodeName' ){];
        }
    }

    return $results;
}

sub process_cwe_file {

    my ($filename) = @_;

    my ($CWE_Entry_HASH) = {};

    my $iter = 0;

    my $element_body;

    my $cwe_fd;

    open( $cwe_fd, q{<}, $filename )
        or die qq{couldn't open "$filename": $!};

    my $content;
    {
        open( $cwe_fd, q{<}, $filename )
            or die qq{couldn't open "$filename": $!};
        my $oldslash = $/;
        local undef $/;
        $content = <$cwe_fd>;
        $/       = $oldslash;
    };

    my ($header) = ( $content =~ /^(.*?<Weakness_Catalog[^>]+>)/msg );
    my $footer = '</Weakness_Catalog>';

    $content = "";

    open( $cwe_fd, q{<}, $filename )
        or die qq{couldn't open "$filename": $!};

    my $current_element;
    my $function;

    my %parent_element = (
        View             => 'Views',
        Category         => 'Categories',
        Weakness         => 'Weaknesses',
        Compound_Element => 'Compound_Elements',
    );

    while ( my $line = <$cwe_fd> ) {
        if (   $line =~ /(^.*?)<(View|Category|Weakness|Compound_Element)[> ]/
            || $line =~ m:(^.*?)</Weakness_Catalog>:    # last entry
            )
        {
            my $tail         = $1;
            my $next_element = $2;
            my $lcelement    = lc $next_element if $next_element;

            if ( !$current_element ) {
                $current_element = $next_element;
                my $funcname = "process_$lcelement";
                $function = \&$funcname;
                $line =~ s/^$tail//;
                $content = $line;

                next;
            } elsif ( $current_element && $current_element ne $next_element )
            {
                $content =~ s:</$parent_element{$current_element}>::;
                $content =~ s:<$parent_element{$next_element}>::;
            }

            $content .= $tail;

            $element_body = $content;

            my $xml_string
                = (   "$header\n"
                    . "<$parent_element{$current_element}>\n"
                    . "$element_body\n"
                    . "</$parent_element{$current_element}>\n"
                    . "$footer\n" );

            my %cwe = $function->($xml_string);

            while ( my ( $id, $element ) = each %cwe ) {

                #                $CWE_Entry_HASH->{" ${lcelement} _ $id
                #                "} = $element;
            }

            $iter++;

            $line =~ s/^$tail//;
            $content = $line;

            if ( $next_element && $current_element ne $next_element ) {
                $current_element = $next_element;
                my $funcname = "process_$lcelement";
                $function = \&$funcname;
            }

        } else {
            $content .= $line;
        }

    }

}

sub process_weakness {
    my ($weakness_xml) = @_;

    my $xp = eval { XML::XPath->new( xml => $weakness_xml ) };
    croak "couldn't parse xml:\n" . $weakness_xml . "\n\n" . $@ if $@;

    my $nodeset = $xp->find('/Weakness_Catalog/Weaknesses/Weakness');

    my @weakness_nodelist = grep { $_->getName && $_->getName eq 'Weakness' }
        $nodeset->get_nodelist;

    return ( 'weakness_id' => {} );
}

sub process_view {
    my ($view_xml) = @_;

    my $results = {};

    my $xp = eval { XML::XPath->new( xml => $view_xml ) };
    croak "couldn't parse xml:\n" . $view_xml . "\n\n" . $@ if $@;

    my $class = 'XML::XPath';

    croak "XP is not a [$class]: " . Data::Dumper::Dumper($xp)
        unless ref $xp eq $class;

    my $nodeset = $xp->find('/Weakness_Catalog/Views/View');

    my @view_nodelist = grep { $_->getName && $_->getName eq 'View' }
        $nodeset->get_nodelist;

    foreach my $view (@view_nodelist) {
        foreach my $attr ( $view->getAttributes() ) {
            next unless $attr;
            $results->{ $attr->getName() } = $attr->getNodeValue();
        }

        foreach my $element ( $view->getChildNodes() ) {
            my $type = ref $element;

            my $str = $element->string_value();

            if ( $type eq 'XML::XPath::Node::Text' ) {
                next if $str =~ /^\s*$/;
            } elsif ( $type eq 'XML::XPath::Node::Element' ) {

            }

            die "\n" . "type: [$type]\n" . "value: [$str]" . "\n";

            my $nodeName;

            $nodeName = $element->getName()
                if $element->can('getName');

            if ( $nodeName eq 'View_Structure' ) {
                $results->{$nodeName} = $element->string_value();
            } elsif ( $nodeName eq 'View_Objective' ) {

                die "moo objective";

                my $text = $element->find('/Text');
                foreach my $text_node ( $text->get_nodelist ) {

                    push(
                        @{ $results->{$nodeName} },
                        $text_node->string_value()
                    );
                }

            }
        }

    }

}

sub process_views {
    my ($xml) = @_;
    print "v";

    my $xp = XML::XPath->new( xml => $xml );

    my $nodeset = $xp->find('//View');

    my @view_nodelist = grep { $_->getName && $_->getName eq 'View' }
        $nodeset->get_nodelist;

    foreach my $view_node (@view_nodelist) {
        my $view = process_view($view_node);
    }

    return ( 'view_id' => {} );
}

sub process_category {
    print "c";
    return ( 'category_id' => {} );
}

sub process_compound_element {
    print "e";
    return ( 'compound_id' => {} );
}
